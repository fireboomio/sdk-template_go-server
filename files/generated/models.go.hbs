package generated

{{#each operations}}
{{#if (isAnyTrue hasInput hasInternalInput (isNotEmpty inputSchema.definitions) hasInjectedInput (isNotEmpty responseSchema))}}
type (
	{{#if (isNotEmpty inputSchema)}}
		{{#if hasInput}}
    {{> struct_definition mergeType=true requiredKeys=inputSchema.required schemaData=inputSchema.properties parentName=(fmtSprintf '%sInput' name)}}
        {{/if}}
        {{#if hasInternalInput}}
    {{> struct_definition mergeType=true requiredKeys=internalSchema.required schemaData=internalSchema.properties parentName=(fmtSprintf 'Internal%sInput' name)}}
        {{/if}}
        {{#each inputSchema.definitions as |schema name|~}}
    {{#if (isAbsent onceMap (fmtSprintf 'models_%s' name) schema)}}
    {{> struct_definition mergeType=true requiredKeys=schema.required schemaData=schema.properties parentName=name}}
    {{/if}}
        {{/each}}
    {{~/if}}
    {{~#equal engine 0}}
        {{~#if (isAllTrue (isNotEmpty injectedSchema) hasInjectedInput)}}
    {{> struct_definition mergeType=true requiredKeys=injectedSchema.required schemaData=injectedSchema.properties parentName=(fmtSprintf 'Injected%sInput' name)}}
        {{else}}
    {{fmtSprintf 'Injected%sInput' name}} = any
        {{/if}}
        {{#if (isNotEmpty responseSchema)}}
            {{#with responseSchema.properties.data}}
    {{> struct_definition mergeType=true requiredKeys=required schemaData=properties parentName=(fmtSprintf '%sResponseData' name)}}
            {{/with}}
        {{/if}}
    {{~/equal~}}
    {{~#each subSchemaMap as |schema name|~}}
        {{~> struct_recursion requiredKeys=schema.required schemaData=schema.schema parentName=name~}}
    {{~/each}}
    {{~#each subSchemaMap as |schema name|}}
    {{> struct_definition mergeType=true requiredKeys=schema.required schemaData=schema.schema parentName=name}}

    {{/each}}
)
{{/if}}
{{/each}}